#!/usr/bin/env python

from __future__ import print_function
from subprocess import Popen, PIPE

"""
ts.py

A "tandem simulator," which wraps an alignment tool as it runs, eavesdrops on
input and output, simulates a new dataset similar to the input data, aligns
it, uses those alignments as training data to build a model to predict MAPQ,
then re-calcualtes MAPQs for the original input using that predictor.
"""

import os
from os.path import join, getsize
import sys
import time
import logging
import errno
try:
    from Queue import Queue, Empty, Full
except ImportError:
    from queue import Queue, Empty, Full  # python 3.x

# Modules that are part of the tandem simulator
from bowtie2 import AlignmentBowtie2, Bowtie2
from bwamem import AlignmentBwaMem, BwaMem
from snap import AlignmentSnap, SnapAligner
from tempman import TemporaryFileManager

__author__ = "Ben Langmead"
__email__ = "langmea@cs.jhu.edu"

bin_dir = os.path.dirname(os.path.realpath(__file__))

VERSION = '0.2.0'


class Timing(object):

    def __init__(self):
        self.labs = []
        self.timers = dict()

    def start_timer(self, lab):
        self.labs.append(lab)
        self.timers[lab] = time.time()

    def end_timer(self, lab):
        self.timers[lab] = time.time() - self.timers[lab]

    def __str__(self):
        ret = []
        for lab in self.labs:
            ret.append('\t'.join([lab, str(self.timers[lab])]))
        return '\n'.join(ret) + '\n'


def sanity_check_binary(exe):
    if not os.path.exists(exe):
        raise RuntimeError('Binary "%s" does not exist' % exe)
    else:
        if not os.access(exe, os.X_OK):
            raise RuntimeError('Binary "%s" exists but is not executable' % exe)


def mkdir_quiet(dr):
    # Create output directory if needed
    if not os.path.isdir(dr):
        try:
            os.makedirs(dr)
        except OSError as exception:
            if exception.errno != errno.EEXIST:
                raise


def recursive_size(dr):
    tot = 0
    for root, dirs, files in os.walk(dr):
        tot += sum(getsize(join(root, name)) for name in files)
    return tot


def go(args, aligner_args, aligner_unpaired_args, aligner_paired_args):

    tim = Timing()
    tim.start_timer('Overall')

    # Sanity-check arguments
    if not args['input_reads_simulated'] and args['write_test_distances']:
        raise RuntimeError('if --write-test-distances is set, --input-reads-simulated must also be')

    # Create output directory if needed
    odir = args['output_directory']
    mkdir_quiet(odir)

    # Set up logger
    logging.basicConfig(format='%(asctime)s:%(levelname)s:%(message)s', datefmt='%m/%d/%y-%H:%M:%S',
                        level=logging.DEBUG if args['verbose'] else logging.INFO)
    fn = join(odir, 'ts_logs.txt')
    fh = logging.FileHandler(fn)
    fh.setLevel(logging.DEBUG)
    logging.getLogger('').addHandler(fh)

    if args['U'] is not None and args['m1'] is not None:
        raise RuntimeError('Input must consist of only unpaired or only paired-end reads')
    
    # Start building alignment command; right now we support Bowtie 2, BWA-MEM and SNAP
    aligner_class, alignment_class = Bowtie2, AlignmentBowtie2
    align_cmd = None
    if args['aligner'] == 'bowtie2':
        align_cmd = 'bowtie2 '
        if args['bt2_exe'] is not None:
            align_cmd = args['bt2_exe'] + " "
        aligner_args.extend(['--mapq-extra'])  # TODO: do we want --reorder?
    elif args['aligner'] == 'bwa-mem':
        align_cmd = 'bwa mem '
        if args['bwa_exe'] is not None:
            align_cmd = args['bwa_exe'] + ' mem '
        aligner_class, alignment_class = BwaMem, AlignmentBwaMem
    elif args['aligner'] == 'snap':
        align_cmd = 'snap-aligner '
        if args['snap_exe'] is not None:
            align_cmd = args['snap_exe'] + ' '
        aligner_class, alignment_class = SnapAligner, AlignmentSnap
    elif args['aligner'] is not None:
        raise RuntimeError('Aligner not supported: "%s"' % args['aligner'])

    # for storing temp files and keep track of how big they get
    temp_man = TemporaryFileManager(args['temp_directory'])

    def _get_pass1_file_prefix():
        """
        Return the file prefix that should be used for naming intermediate
        files generated by qsim-parse when parsing input SAM.
        """
        if args['write_all'] or args['write_input_intermediates']:
            def _purge():
                pass
            return join(odir, 'input_intermediates'), _purge
        else:
            dr = temp_man.get_dir('input_intermediates', 'input_intermediates')

            def _purge():
                dr.remove_group('input_intermediates')
            return join(dr, 'tmp'), _purge

    def _get_pass2_file_prefix():
        """
        Return the file prefix that should be used for naming intermediate
        files generated by qsim-parse when parsing the tandem SAM.
        """
        if args['write_all'] or args['write_tandem_intermediates']:
            def _purge():
                pass
            return join(odir, 'tandem_intermediates'), _purge
        else:
            dr = temp_man.get_dir('tandem_intermediates', 'tandem_intermediates')

            def _purge():
                dr.remove_group('tandem_intermediates')
            return join(dr, 'tmp'), _purge

    parse_input_exe = "%s/qsim-parse" % bin_dir

    def _get_passthrough_args():
        op = Popen(parse_input_exe, stdout=PIPE).communicate()[0]
        ls = []
        for ar in op.strip().split(' '):
            ar = ar.replace('-', '_')
            assert ar in args, "\"%s\"" % ar
            logging.debug('  passing through argument "%s"="%s"' % (ar, str(args[ar])))
            ls.append(ar)
            ls.append(str(args[ar]))
        return ' '.join(ls)

    def _wait_for_aligner(_al):
        while _al.pipe.poll() is None:
            time.sleep(0.5)

    def _exists_and_nonempty(fn):
        return os.path.exists(fn) and os.stat(fn).st_size > 0

    def _have_unpaired_tandem_reads(prefix):
        ufn = prefix + '_reads_u.fastq'
        bfn = prefix + '_reads_b.fastq'
        return _exists_and_nonempty(ufn) or _exists_and_nonempty(bfn)

    def _have_paired_tandem_reads(prefix):
        cfn = prefix + '_reads_c_1.fastq'
        dfn = prefix + '_reads_d_1.fastq'
        return _exists_and_nonempty(cfn) or _exists_and_nonempty(dfn)

    def _unpaired_tandem_reads(prefix):
        ls = []
        ufn = prefix + '_reads_u.fastq'
        if _exists_and_nonempty(ufn):
            ls.append(ufn)
        bfn = prefix + '_reads_b.fastq'
        if _exists_and_nonempty(bfn):
            ls.append(bfn)
        return ls

    def _paired_tandem_reads(prefix):
        ls1, ls2 = [], []
        cfn1 = prefix + '_reads_c_1.fastq'
        cfn2 = prefix + '_reads_c_2.fastq'
        if _exists_and_nonempty(cfn1):
            ls1.append(cfn1)
            ls2.append(cfn2)
        bfn1 = prefix + '_reads_b_1.fastq'
        bfn2 = prefix + '_reads_b_2.fastq'
        if _exists_and_nonempty(bfn1):
            ls1.append(bfn1)
            ls2.append(bfn2)
        return zip(ls1, ls2)

    # ##################################################
    # 1. Align input reads
    # ##################################################

    tim.start_timer('Aligning input reads')
    sam_fn = join(odir, 'input.sam')
    logging.info('Command for aligning input data: "%s"' % align_cmd)
    aligner = aligner_class(
        align_cmd,
        aligner_args,
        aligner_unpaired_args,
        aligner_paired_args,
        args['index'],
        unpaired=args['U'],
        paired=None if args['m1'] is None else zip(args['m1'], args['m2']),
        sam=sam_fn)

    logging.debug('  waiting for aligner to finish...')
    _wait_for_aligner(aligner)
    logging.debug('  aligner finished; results in "%s"' % sam_fn)
    tim.end_timer('Aligning input reads')

    # ##################################################
    # 2. Parse input SAM
    # ##################################################

    tim.start_timer('Parsing input alignments')
    sanity_check_binary(parse_input_exe)
    pass1_prefix, pass1_cleanup = _get_pass1_file_prefix()
    cmd = "%s ifs -- %s -- %s -- %s -- %s" % \
          (parse_input_exe, _get_passthrough_args(), sam_fn, ' '.join(args['ref']), pass1_prefix)
    logging.info('  running "%s"' % cmd)
    ret = os.system(cmd)
    if ret != 0:
        raise RuntimeError("qsim-parse returned %d" % ret)
    pass1_cleanup()
    logging.debug('  parsing finished; results in "%s.*"' % pass1_prefix)
    tim.end_timer('Parsing input alignments')

    # ##################################################
    # 3. Align tandem reads
    # ##################################################

    tim.start_timer('Aligning tandem reads')
    if _have_unpaired_tandem_reads(pass1_prefix) and _have_paired_tandem_reads(pass1_prefix) and aligner.supports_mix():
        logging.info('Aligning tandem reads (mix)')
        aligner = aligner_class(
            align_cmd,
            aligner_args,
            aligner_unpaired_args,
            aligner_paired_args,
            args['index'],
            unpaired=_unpaired_tandem_reads(pass1_prefix),
            paired=_paired_tandem_reads(pass1_prefix),
            sam=sam_fn,
            input_format='fastq')
        _wait_for_aligner(aligner)
        logging.debug('Finished aligning unpaired and paired-end tandem reads')
    else:
        if _have_unpaired_tandem_reads():
            logging.info('Aligning tandem reads (unpaired)')
            aligner = aligner_class(
                align_cmd,
                aligner_args,
                aligner_unpaired_args,
                aligner_paired_args,
                args['index'],
                unpaired=_unpaired_tandem_reads(pass1_prefix),
                sam=sam_fn,
                input_format='fastq')
            _wait_for_aligner(aligner)
            logging.debug('Finished aligning unpaired tandem reads')
        if _have_paired_tandem_reads():
            logging.info('Aligning tandem reads (paired)')
            aligner = aligner_class(
                align_cmd,
                aligner_args,
                aligner_unpaired_args,
                aligner_paired_args,
                args['index'],
                paired=_paired_tandem_reads(pass1_prefix),
                sam=sam_fn,
                input_format='fastq')
            _wait_for_aligner(aligner)
            logging.debug('Finished aligning paired tandem reads')
    tim.end_timer('Aligning tandem reads')

    # ##################################################
    # 4. Parse tandem alignments
    # ##################################################

    tim.start_timer('Parsing tandem alignments')
    sanity_check_binary(parse_input_exe)
    pass2_prefix, pass2_cleanup = _get_pass2_file_prefix()
    cmd = "%s f -- %s -- %s -- %s -- %s" % \
          (parse_input_exe, _get_passthrough_args(), sam_fn, ' '.join(args['ref']), pass2_prefix)
    logging.info('  running "%s"' % cmd)
    ret = os.system(cmd)
    if ret != 0:
        raise RuntimeError("qsim-parse returned %d" % ret)
    pass2_cleanup()
    logging.debug('  parsing finished; results in "%s.*"' % pass2_prefix)
    tim.end_timer('Parsing tandem alignments')

    # ##################################################
    # 5. Predict
    # ##################################################

    tim.start_timer('Make MAPQ predictions')

    tim.end_timer('Make MAPQ predictions')

    # ##################################################
    # 6. Rewrite SAM
    # ##################################################

    tim.start_timer('Rewrite SAM file')

    tim.end_timer('Rewrite SAM file')

    temp_man.purge()
    logging.info('Peak temporary file size: %0.2fMB' % (temp_man.peak_size / (1024.0 * 1024)))
    logging.info('Total size of output directory: %0.2fMB' % (recursive_size(odir) / (1024.0 * 1024)))

    tim.end_timer('Overall')
    for ln in str(tim).split('\n'):
        if len(ln) > 0:
            logging.info(ln)
    if args['write_timings'] or args['write_all']:
        with open(join(odir, 'timing.tsv'), 'w') as fh:
            fh.write(str(tim))
    logging.info('Time overhead: %0.01f%%' % (100.0 * (tim.timers['Overall'] - tim.timers['Aligning input reads']) /
                                              tim.timers['Aligning input reads']))


def add_args(parser):
    # Inputs
    parser.add_argument('--ref', metavar='path', type=str, nargs='+', required=True,
                        help='FASTA file(s) containing reference genome sequences')
    parser.add_argument('--U', metavar='path', type=str, nargs='+', help='Unpaired read files')
    parser.add_argument('--m1', metavar='path', type=str, nargs='+',
                        help='Mate 1 files; must be specified in same order as --m2')
    parser.add_argument('--m2', metavar='path', type=str, nargs='+',
                        help='Mate 2 files; must be specified in same order as --m1')
    parser.add_argument('--index', metavar='path', type=str, help='Index file to use (usually a prefix).')

    parser.add_argument('--seed', metavar='int', type=int, default=99099, required=False,
                        help='Integer to initialize pseudo-random generator')

    parser.add_argument('--sim-fraction', metavar='fraction', type=float, default=0.01, required=False,
                        help='When determining the number of simulated reads to generate for each type of '
                             'alignment (concordant, discordant, bad-end, unpaired), let it be no less '
                             'than this fraction times the number of alignment of that type in the input '
                             'data.')
    parser.add_argument('--sim-unp-min', metavar='int', type=int, default=30000, required=False,
                        help='Number of simulated unpaired reads will be no less than this number.')
    parser.add_argument('--sim-conc-min', metavar='int', type=int, default=30000, required=False,
                        help='Number of simulated concordant pairs will be no less than this number.')
    parser.add_argument('--sim-disc-min', metavar='int', type=int, default=10000, required=False,
                        help='Number of simulated discordant pairs will be no less than this number.')
    parser.add_argument('--sim-bad-end-min', metavar='int', type=int, default=10000, required=False,
                        help='Number of simulated pairs with-one-bad-end will be no less than this number.')

    parser.add_argument('--max-allowed-fraglen', metavar='int', type=int, default=100000, required=False,
                        help='When simulating fragments, observed fragments longer than this will be'
                             'truncated to this length')
    parser.add_argument('--low-score-bias', metavar='float', type=float, default=1.0, required=False,
                        help='When simulating reads, we randomly select a real read\'s alignment profile'
                             'as a template.  A higher value for this parameter makes it more likely'
                             'we\'ll choose a low-scoring alignment.  If set to 1, all templates are'
                             'equally likely.')
    parser.add_argument('--fraction-even', metavar='float', type=float, default=1.0, required=False,
                        help='Fraction of the time to sample templates from the unstratified input '
                             'sample versus the stratified sample.')
    parser.add_argument('--input-model-size', metavar='int', type=int, default=10000, required=False,
                        help='Number of templates to keep when building input model.')
    parser.add_argument('--ref-soft-clipping', action='store_const', const=True, default=False,
                        help='Use bases from reference (instead of random bases) to re-align soft clipped bases.')
    parser.add_argument('--input-reads-simulated', action='store_const', const=True, default=False,
                        help='Input reads are simulated and should be evaluated for True/False.')

    parser.add_argument('--wiggle', metavar='int', type=int, default=30, required=False,
                        help='Wiggle room to allow in starting position when determining whether alignment is correct')

    parser.add_argument('--sam-input', metavar='path', type=str,
                        help='Input SAM file to apply training data to.  Use with --training-input.')
    parser.add_argument('--bt2-exe', metavar='path', type=str, help='Path to Bowtie 2 exe')
    parser.add_argument('--bwa-exe', metavar='path', type=str, help='Path to BWA exe')
    parser.add_argument('--snap-exe', metavar='path', type=str, help='Path to snap-aligner exe')
    parser.add_argument('--aligner', metavar='name', default='bowtie2', type=str,
                        help='bowtie2 | bwa-mem | snap')

    # For when input is itself simulated, so we can output a Dataset with the
    # 'correct' column filled in properly
    parser.add_argument('--correct-chromosomes', metavar='list', type=str, nargs='+',
                        help='Label test data originating from any of these chromosomes as "correct."  Useful for '
                             'tests on real-world data where it is known that the data came from a parituclar '
                             'chromosome.')

    # Output file-related arguments
    parser.add_argument('--temp-directory', metavar='path', type=str, required=False,
                        help='Write temporary files to this directory; default: uses environment variables '
                             'like TMPDIR, TEMP, etc')
    parser.add_argument('--output-directory', metavar='path', type=str, required=True,
                        help='Write outputs to this directory')
    parser.add_argument('--write-training-reads', action='store_const', const=True, default=False,
                        help='Write FASTQ for the training reads to "training.fastq" in output directory')
    parser.add_argument('--write-test-data', action='store_const', const=True, default=False,
                        help='Write Dataset object for training data.  "Correct" column set to all None\'s.')
    parser.add_argument('--write-training-sam', action='store_const', const=True, default=False,
                        help='Write SAM alignments for the training reads to "training.sam" in output directory')
    parser.add_argument('--write-test-distances', action='store_const', const=True, default=False,
                        help='Write distances between true/actual alignments.')
    parser.add_argument('--write-timings', action='store_const', const=True, default=False,
                        help='Write timing info to "timing.tsv".')
    parser.add_argument('--write-all', action='store_const', const=True, default=False,
                        help='Same as specifying all --write-* options')


def go_profile(args, aligner_args, aligner_unpaired_args, aligner_paired_args):
    if args['profile']:
        import cProfile
        cProfile.run('go(args, aligner_args, aligner_unpaired_args, aligner_paired_args)')
    else:
        go(args, aligner_args, aligner_unpaired_args, aligner_paired_args)


def parse_aligner_parameters_from_argv(_argv):
    argv = _argv[:]
    sections = [[]]
    for arg in argv:
        if arg == '--':
            sections.append([])
        else:
            sections[-1].append(arg)
    new_argv = sections[0]
    aligner_args = [] if len(sections) < 2 else sections[1]
    aligner_unpaired_args = [] if len(sections) < 3 else sections[2]
    aligner_paired_args = [] if len(sections) < 4 else sections[3]
    return new_argv, aligner_args, aligner_unpaired_args, aligner_paired_args


if __name__ == "__main__":
    
    import argparse

    _parser = argparse.ArgumentParser(
        description='Align a collection of input reads, simulate a tandem'
                    'dataset, align the tandem dataset, and emit both the'
                    'input read alignments and the training data derived from'
                    'the tandem read alignments.')

    if '--version' in sys.argv:
        print('Tandem simulator, version ' + VERSION)
        sys.exit(0)

    add_args(_parser)

    # Some basic flags
    _parser.add_argument('--profile', action='store_const', const=True, default=False, help='Print profiling info')
    _parser.add_argument('--verbose', action='store_const', const=True, default=False, help='Be talkative')
    _parser.add_argument('--version', action='store_const', const=True, default=False, help='Print version and quit')

    _argv, _aligner_args, _aligner_unpaired_args, _aligner_paired_args = parse_aligner_parameters_from_argv(sys.argv)
    _args = _parser.parse_args(_argv[1:])

    go_profile(vars(_args), _aligner_args, _aligner_unpaired_args, _aligner_paired_args)
